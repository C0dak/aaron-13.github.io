# Lua

------

## 简介

Lua是一门扩展式程序设计语言，被设计成支持通用过程式编程，并有相关数据描述设施。同时对面向对象编程，函数式编程和数据驱动式编程提供了良好的支持。它作为一个强大，轻量的嵌入式脚本语言，可供任何需要的程序使用。Lua由clean C(C和C++间共通的子集)实现成一个库。

作为一门扩展式语言，Lua没有main程序的概念，只能嵌入一个宿主程序中工作，该宿主程序被称为被嵌入程序或者简称宿主。宿主程序可以调用函数执行一小段Lua代码，可以读写Lua变量，可以注册C函数让Lua代码调用。依靠C函数，Lua可以共享相同的语法框架来定制编程语言，从而适用不同的领域。

Lua是一个自由的软件，其使用许可证决定了它的使用过程无需任何担保。



## 基本概念

**值与类型**

Lua是一门动态类型语言，变量没有类型，只有值才有类型。语言中不设类型定义，所有的值携带自己的类型。

Lua中所有的值都是一等公民，所有的值均可保存在变量中，当做参数传递给其他函数以及作为返回值。

Lua中有八种基本类型: nil,boolean,number,string,function,userdata,thread和table.
Nil是值nil的类型，其主要特征就是和其他值区别开；通常用来表示一个有意义的值不存在的时的状态。
Boolean是false与true两个值的类型。
nil和false都会导致条件判断为假；而其他任何值都表示为真。
Number代表了整数与实数(浮点数)。
String表示一个不可变的字节序列。
Lua对8位是友好的:字符串可以容纳任意8位值，其中包含零('\0').Lua的字符串与编码无关，不关心字符串中具体内容。
标准的Lua使用64位整数和双精度64位浮点数，也可以把Lua编译成使用32位整数和单精度(32位)浮点数。

userdata类型允许将C中的数据保存在Lua变量中。用户数据类型的值是一个内存块，有两种用户数据:完全用户数据，指一块由Lua管理的内存对应的对象；轻量用户数据，则指一个简单的C指针。用户数据在Lua中除了赋值与相等性判断外没有其他预定义的操作。通过使用元表，可以给完全用户数据定义一系列的操作。只能通过C API而无法在Lua代码中创建或者修改用户数据的值，保证了数据仅被宿主程序所控制。

thread类型表示了一个独立的执行序列，被用于实现协程。Lua的线程与操作系统的线程毫无关系。Lua位所有的系统，包括哪些不支持原生现成的系统，提供了协程支持。

table是一个关联数组，这个数组不仅仅以数字做索引，除了nil和NaN之外所有的Lua值都可以做索引。表可以是异构的，即表内可以包含任何类型的值(nil除外)，对于表内不存在的键，都对应着值nil。

表是Lua中唯一的数据结构，可被用于表示普通数组，序列，符号表，集合，记录，图，树等，对于记录，Lua使用域名作为索引。

索引一张表的原则遵循语言中的直接比较规则。当且仅当i和j直接比较相等时(不通过元方法的比较)，表达式a[i]和a[j]表示表中相同的元素。

表，函数，线程，以及完全用户数据在Lua中被称为对象，变量并不真的持有它们的值，而仅保存了对这些对象的引用。赋值，参数传递，函数返回，都是针对引用而不是针对值的操作，这些操作均不会做任何形式的隐士拷贝。

库函数type用于以字符串形式返回给定值的类型。


**环境与全局环境**
被`_ENV`用于值的那张表被称为环境。
Lua保有一个被称为全局环境特别环境。它被保存在C注册表的一个特别索引下，在Lua中，全局变量_G被初始化为这个值。(_G不被内部任何地方使用)

当Lua加在一个代码块，_ENV这个值上的默认值就是这个全局环境。因此，在默认情况下，Lua代码中提及的自由名字都指的全局环境中的相关项。此外，所有的标准库都被加载入全局环境，一些函数也针对这个环境做操作。可以用load(或loadfile)加载代码块，并赋予不同的环境。


**错误处理**
Lua是一门嵌入式扩展语言，其所有行为均源于宿主程序中C代码对某个Lua库函数的调用。(单独使用Lua时，lua程序就是宿主程序)所以，在编译或运行Lua代码块的过程中，无何时发生错误，控制权都会返回给宿主，由宿主负责采取恰当的措施。

可以在Lua代码中调用error函数来显示地抛出一个错误。如果需要在Lua中捕获这些错误，可以使用pcall或xpcall在保护模式下调用一个函数。

使用xpcall或者lua_pcall时，应该提供一个消息处理函数用于错误抛出时调用。该函数需接收原始的错误消息，并返回一个新的错误消息。它在错误发生后栈尚未展开时调用，因此可以利用栈来收集更多的信息，比如通过探知栈来创建一组栈回溯信息，同时，该处理函数也处于保护模式下，所以该函数内发生错误会再次触发它。


**元表及元方法**
Lua中的每个值都可以有一个元表。这个元表就是一个普通的Lua表，它用于定义原始值在特定操作下的行为。如果想改变一个值在特定操作下的行为，可以在它的元表中设置对应域。

元表中的键对应着不同的事件名；键关联的那些值被称为元方法。可以用getmetatable函数来获取任何值的元表。

使用setmetatable来替换一张表的元表。在Lua中，不可以改变表以外其他类型的值的元表。(除非使用调试库)，若想改变这些非表类型的值的元表，使用C API。

表和完全用户数据有独立的元表(多个表和用户数据可以共享同一个元表)。其他类型的值按类型共享元表，即所有的数字都共享同一个元表，所有的字符串共享另一个元表等。默认情况下，值是没有元表的。但字符串库在初始化的时候为字符串类型设置了元表。

元表决定了一个对象在数学运算，位运算，比较，连接，取长度，调用，索引时的行为。元表还可以定义一个函数，当表对象或用户数据对象在垃圾回收时调用它。

一张元表可以控制的事件的完整列表。每个操作都用对应的事件名来区分。每个事件的键名用加有'__'前缀的字符串来表示。注意，Lua从元表中直接获取元方法；访问元表中的元方法永远不会触发另一次元方法。模拟Lua从一个对象obj中获取一个元方法的过程:
```
rawget(getmetatable(obj) or {},"__" .. event_name)
```

对于一元操作符(取反，求长度，位反)，元方法调用的时候，第二个参数是哑元，其值等于第一个参数，这样处理仅仅是为了简化Lua的内部实现。

+ add: +操作。如果任何不是数字的值(包括不能转换为数字的字符串)做加法，Lua就会尝试调用元方法，首先，Lua检查第一个操作数，如果这个操作数没有为"__add"事件定义元方法，Lua就会接着检查第二个操作数，一旦Lua找到元方法，它将把两个操作数作为参数传入元方法，元方法的结果(调整为单个值)作为这个操作的结果。如果找不到元方法，将抛出一个错误。

+ sub: - 操作，行为和add类似

+ mul: * 操作，行为和add类似

+ div: / 操作，行为和add类似

+ mod: % 操作，行为和add类似

+ pow: ^ 次方操作，行为和add类似

+ unm: - 取负操作，行为和add类似

+ idiv: // 向下取整除法操作，行为和add类似

+ band: & 按位与操作，行为和add类似，不同的是Lua会在任何一个操作数无法转换为整数时，尝试元方法

+ bor: | 按位或操作，行为和band类似

+ bxor: ~ 按位异或操作，行为和band类似

+ bnot: ~ 按位非操作，行为和band类似

+ shl: &lt;&lt; 左移操作，行为和band类似

+ shr: &gt;&gt; 右移操作，行为和band类似

+ concat: 连接操作，和add操作类似。不同的是Lua在任何操作数即不是一个字符串也不是数字(数字总能转换为对应的字符串)的情况下尝试元方法。

+ len: # 取长度操作。如果对象不是字符串，Lua会尝试它的元方法，如果有元方法，则调用它并将对象以参数形式传入，而返回值则作为结果。如果对象是一张表且没有元方法，Lua使用表的取长度操作。

+ eq: == 等于操作。和add操作类似。不同的是Lua仅在两个值都是表或都是完全用户数据且它们不是同一个对象时才尝试元方法。调用的结果总会被转换为布尔量。

+ lt: &lt; 小于操作，和add操作行为类似。不同的是Lua仅在两个值不全为整数也不全为字符串时才尝试元方法，调用的结果总会被转换为布尔量。

+ le: &lt;= 小于等于操作。首先，像lt操作的行为那样，Lua在两个操作数中查找__le元方法，如果一个元方法都找不到，就会再次查找__lt时间，它会假设a &lt;= b 等价于 not (b &lt; a)

+ index: 索引  table[key]，当table不是表或是表table中不存在key这个键时，这个事件被触发，此时，会读出table相应的元方法。这个事件的元方法其实可以是一个函数也可以是一张表，如果它是一个函数，则以table和key作为参数调用它，如果是一张表，最终的结果就是以key取索引这张表的结果。

+ newindex: 索引赋值 table[key]=value,和索引事件类似，它发生在table不是表或是表table中不存在key这个键的时候，此时，会读出table相应的元方法。

同索引过程那样， 这个事件的元方法即可以是函数，也可以是一张表。 如果是一个函数， 则以 table、 key、以及 value 为参数传入。 如果是一张表， Lua 对这张表做索引赋值操作。 （这个索引过程是走常规的流程，而不是直接索引赋值， 所以这次索引赋值有可能引发另一次元方法。）
一旦有了 "newindex" 元方法， Lua 就不再做最初的赋值操作。 （如果有必要，在元方法内部可以调用 rawset 来做赋值。）

+ call: 函数调用操作 func(args) 当Lua尝试调用一个非函数的值的时候会触发这个时间。查找func的元方法，如果找得到，就调用这个元方法，func作为第一个参数传入，原来调用的参数(args)后依次排在后面。



##垃圾收集

------

Lua采用了自动内存管理，Lua运行了一个垃圾收集器来收集所有死对象来完成自动内存管理的工作。Lua中所有用到的内存: 字符串，表，用户数据，函数...都服从自动管理。

Lua实现了一个增量标记-扫描收集器。它使用这两个数字来控制垃圾收集循环: 垃圾收集器间歇率和垃圾收集器步进倍率。

垃圾收集器间歇率控制着收集器需要在开启新的循环前要等待多久。增大这个值会减少收集器的积极性。当这个值比100小的时候，收集器在开启新的循环前不会有等待。设置这个值为200就会让收集器等到总内存使用量达到之前的两倍的时候才开始新的循环。

垃圾收集器步进倍率控制着收集器运作速度相对于内存分配速度的倍率。增大这个值不仅会让收集器更加积极，还会增加每个增量步骤的长度，不要把这个值设的小于100，那样永远处于一个干不完的循环中。默认值是200.

可以通过C中调用lua_gc或者Lua中调用collectgarbage来改变这俩数字。这两个函数也可以用来直接控制收集器停止或重启。


**垃圾收集元方法**

可以为表设定垃圾收集的元方法，对于完全用户数据，需要使用C API。该元方法被称为终接器。终接器允许配置Lua的垃圾收集器做一些额外的资源管理工作(关闭文件，网络或数据库连接，或者释放一些内存)

如果要让一个对象在收集过程中进入终结流程，必须标记它需要触发终结器。当为一个对象设置元表时，若此刻这张元表中用一个以字符串"__gc"为索引的域，那么就标记了这个对象需要触发终结器。如果给对象设置了一个没有__gc域的元表，之后才给元表加上这个域，那么这个对象是没有被标记成需要触发终结器的。然而，一旦对象呗标记，还可以自由的改变其元表中的__gc域的。

当一个被标记的对象成为垃圾后，垃圾收集器并不会立刻回收，取而代之的是，Lua会将其置入一个链表。在收集完成后，Lua将遍历这个链表，Lua会检查每个链表中的对象的__gc元方法：如果是一个函数，那么就以对象为唯一参数调用它，否则忽略。

在每次垃圾收集循环的最后阶段，本次循环中检测到的需要被回收之对象，其终结器的触发次序按当前给对象按当前给对象作需要触发终结器的标记之次序的逆序进行。每个终结器的运行可能会发生在执行常规代码过程中的任意一刻

由于被回收的对象还需要被终结器使用，该对象一定会被Lua复活。通常，复活是短暂的，对象所属内存会在下一个垃圾收集循环释放。然后，若终结器又将对象保存去一些全局的地方，这次复活就持续生效。此外，如果在终结器中对一个正进入终结流程的对象再次做一次标记让它触发终结器，只要这个对象在下个循环中依旧不可达，它的终结函数还会再调用一次。无论是哪种情况，对象所属内存仅在垃圾收集循环中该对象不可达且没有被标记成需要触发终结器才会被释放。

当你关闭一个状态机，Lua将调用所有被标记了需要触发终结器对象的终结过程，其次序为标记次序的逆序，在这个过程中，任何终结器再次标记对象的行为都不会生效。


**弱表**

弱表指内部元素为弱引用的表。垃圾收集器会忽略掉弱引用，换句话说，如果一个对象只被弱引用引用到，垃圾收集器就会回收这个对象。

一张弱表可以有弱键或是弱值，也可以键值都是弱引用。仅含有弱键的表允许收集器回收它的键，但会阻止对值所指的对象被回收。若一张表的键值均为弱引用，那么收集器可以回收其中任意键和值。任何情况下，只要键或值的任意一项被回收，相关联的键值都会从表中移除。一张标的元表中的__mode域控制着这张表的弱属性，当__mode域是一个包含字符'k'的字符串时，这张表的所有键皆为弱引用，当__mode域是一个包含字符'v'的字符串时，这张表的所有值皆为弱引用。

属性为弱键强值的表也被称为暂时表。对于一张暂时表，它的值是否可达取决于其对应键是否可达，特别注意，如果表内的一个键仅仅被其值所关联引用，这个键值将被表内移除。

对一张表的弱属性的修改仅在下次收集循环才生效，尤其是当你把表由弱改强，Lua还是有可能在修改生效前回收表内的一些项目。

只有那些有显示构造过程的对象才会从弱表中移除值。例如数字和轻量C函数，不受垃圾收集器管辖，因此不会从弱表中移除(除非它们的关联项被回收)。虽然字符串受垃圾回收管辖，但它们没有显示的构造过程，所以也不会从弱表中移除。

弱表针对复活对象(指那些正在走终结流程，仅能被访问器访问的对象)有着特殊的行为。弱值引用的对象，在运行它们的终结器前就被移除了，而弱键引用的对象则要等到终结器运行完毕后，到下次收集当对象真的被释放时才被移除。这个行为使得终结器运行时得以访问到由该对象在弱表中所关联的属性。

如果一张弱表在当次收集循环内的复活对象中，那么在下个循环前这张表有可能未被正确地清理。


**协程**

Lua支持协程，也叫协同式多线程。一个协程在Lua中代表了一段独立的执行线程。与多线程系统中的线程的区别是，协程仅在显式调用一个让出(yield)函数时才挂起当前的执行。

调用函数 coroutine.create可创建一个协程，其唯一的参数是该协程的主函数，create函数只负责新建一个协程并返回其句柄(一个thread类型的对象);而不会启动该协程。

调用coroutine.resume函数执行一个协程，第一次调用coroutine.resume时，第一个参数应传入coroutine.create返回的线程对象，然后协程从其主函数的第一行开始执行。传递给coroutine.resume的其他参数将作为协程主函数的参数传入，协程启动之后，将一直运行到它终止或让出。

协程的运行可能被两种方式终止:正常途径是主函数返回(显示返回或运行完最后一条指令);非正常途径是发生了一个未被捕获的错误，对于正常结束coroutine.resume将返回true，并接上协程主函数的返回值。当错误发生时，coroutine.resume将返回false与错误信息。

调用coroutine.yield使协程暂停执行，让出执行权。与coroutine.create类似，coroutine.wrap函数也会创造一个协程。不同之处在于，它不返回协程本身，而是返回一个函数。

```
function foo (a)
	print ("foo",a)
	return coroutine.yield(2*a)
end

co = coroutine.create(function (a,b))
	print ("co-body",a,b)
	local r = foo(a+1)
	print ("co-body",r)
	local r,s = coroutine.yield(a+b,a-b)
	print ("co-body",r,s)
	return b,"end"
end)

print ("main",coroutine.resume(co,1,10))
print ("main",coroutine.resume(co,"r"))
print ("main",coroutine.resume(co,"x","y"))
print ("main",coroutine.resume(co,"x","y"))
```

```
    co-body 1       10
    foo     2
    main    true    4
    co-body r
    main    true    11      -9
    co-body x       y
    main    true    10      end
    main    false   cannot resume dead coroutine
```



## 语言定义

------

{a}表示0或多个a，[a]表示一个可选的a。可以被分解的非最终符号会这样写non-terminal，关键字会写成这样kword，而其他不能被分解的最终符号会这样写'='。


**词法约定**

Lua语言的格式自由，会忽略语法元素(符记)间的空格和注释，仅把他们当做名字和关键字之间的分隔符。

Lua的名字可以是由非数字打头的任意字母下划线和数字构成的字符串。标识符可用于对变量，表的域，以及标签命名。

保留的关键字:
```
and       break     do        else      elseif    end
false     for       function  goto      if        in
local     nil       not       or        repeat    return
then      true      until     while
```

Lua语言对大小写敏感: and是一个保留字，但And和AND则是两个不同的名字。作为约定，程序应避免创建以下划线加一个或多个大写字母构成的名字。

Lua中的字符串可以保存任意8位值，其中包括用'\0'表示的0，一般而言，可以用字符的数字值来表示这个字符。方式是用转义串`\x_xx_`,此处的XX必须是恰好两个字符的16进制数。或者使用转义串`\_ddd_`,这里的ddd是一到三个十进制数字。

对于UTF-8编码的Unicode字符，可以用转义符`\u{_XX_}`来表示。字符串还可以用一种长括号括起来的方式定义。把两个正的方括号间插入n个等号定义为第n级开长括号。0级开的长括号写作`[[`,1级开长括号写作`[=[`。一个长字面串可以由任何一级的开长括号开始，有第一个碰到的同级的闭长括号结束。整个词法分析过程将不受分行限制，不处理任何转义符，并且忽略掉任何不同级别的长括号。

```
a = 'alo\n123"'
a = "alo\n123\""
a = '\97lo\10\04923"'
a = [[alo
123"]]
a = [==[
alo
123"]==]
```


**数字常量(数字量)可以由可选的小数部分和可选的十为底的指数部分构成，指数部分用字符'e'或'E'来标记。Lua也接受以0x或0X开头的16进制常量。

```
3   345   0xff   0xBEBADA  //整数常量

//浮点常量
3.0     3.1416     314.16e-2     0.31416E1     34e1
0x0.1E  0xA23p-4   0X1.921FB54442D18P+1
```

在字符串外的任何地方出现以双横线(--)开头的部分是注释。


**变量**

变量时存储值的地方。Lua中有三种变量: 全局变量，局部变量和表的域。

单个名字可以指代一个全局变量也可以指代一个局部变量
```
var ::= Name
```

所有没有显示声明为局部变量的变量名都当做全局变量。
在变量的首次赋值之前，变量的值均为nil。

方括号被用来对表作索引
```
var ::= prefixexp '**[**' exp '**]**'
```

对全局变量以及表的域值访问的含义可以通过元表来改变。以索引方式访问一个变量t[i]等价于调用gettable_event(t,i)。

var.Name用来表示`var[Name]`
```
var ::= prefixexp '**.**' Name
```

对全局变量x的操作等价于操作_ENV.x,由于代码块编译的方式，_ENV永远也不可能是一个全局名字。


**语句**

语句块是一个语句序列，它们会按次序执行:
```
block ::= {stat}
```

Lua支持空语句，可以用分号分隔语句，也可以以分号开始一个语句块，或是连着写两个分号：
```
stat ::= '**;**'
```

函数调用和赋值语句都可能以一个小括号打头，这可能让Lua的语法产生歧义。为了避免这种二义性，在一条语句以小括号开头时，前面放一个分号是好习惯。
```
;(print or io.write)('done')
```

一个语句块可以被显示的定界为单条语句:
```
stat ::= **do** block **end**
```

显示的对一个块定界通常用来控制内部变量声明的作用域，有时，显式定界也用于在一个语句块中键插入return


**代码块**

Lua的一个编译单元被称为一个代码块，从句法构成上讲，一个代码块就是一个语句块。

```
chunk ::= block
```

Lua把一个代码块当做一个拥有不定参数的匿名函数来处理。


**赋值**

Lua允许多重赋值，因此，赋值的语法定义是等号左边放一个变量列表，而等号右边放一个表达式列表。两边的列表中的元素都用逗号隔开:
```
stat ::= varlist '**=**' explist
varlist ::= var {'**.**' var}
explist ::= exp {'**,**' exp}
```

在作赋值操作之前，那值列表会被调整为左边变量列表的个数，如果值比需要的更多的话，多余的值就被扔掉，如果值的数量不够需求，就会按需扩展若干个nil。如果表达式列表以一个函数调用结束，这个函数所返回的所有值都会在调整操作之前被置入值列表中。

赋值语句首先让所有的表达式完成运算，之后再做赋值操作
```
i = 3
i,a[i] = i+1,20
```

会把a[3]设置为20，而不会影响a[4]，这是因为a[i]中的i在被赋值为4之前就被计算出来了。

对全局变量以及表的域的赋值操作的含义可以通过元表来改变，对t[i]=vali这样的变量索引赋值，等价于settable_event(t,i,val)

对于全局变量x=val的赋值等于_ENV.x=val


**控制结构**

if,while and repeat这些控制结构符合通常的意义，而且有类似的语法:
```
stat ::= **while** exp **do** block **end**
stat ::= **repeat** block **utile** exp
stat ::= **if** exp **then** block {**elseif** exp **then** block} [**else** block] **end**

//goto语句将程序的控制点转移到一个标签处
stat ::= **goto** Name
stat ::= label
label ::= '**::**' Name '**::**'

//break被用来结束循环
stat ::= **break**

//return 跳出最内存循环
stat ::= **return** [explist]\['**;**'\]

//for两种形式：一种是数字形式，一种是通用形式
stat ::= **for** Name '**=**' exp '**,**' exp ['**,**' exp] **do** block **end**

for v = _e1_,_e2_,_e3_ do _block_ end

```


**函数调用语句**

```
stat ::= functioncall
```


**局部声明**

```
stat ::= **local* namelist ['**=**' explist]
```

**表达式**
```
    exp ::= prefixexp
    exp ::= **nil** | **false** | **true**
    exp ::= Numeral
    exp ::= LiteralString
    exp ::= functiondef
    exp ::= tableconstructor
    exp ::= ‘**...**’
    exp ::= exp binop exp
    exp ::= unop exp
    prefixexp ::= var | functioncall | ‘**(**’ exp ‘**)**’
```


**操作符**

+ +: 加法
+ -: 减法
+ *: 乘法
+ /: 浮点除法
+ //: 向下取整除法
+ %: 取模
+ ^: 乘方
+ -: 取负

+ &: 按位与
+ |: 按位或
+ ~: 按位异或
+ &gt;&gt;: 右移
+ &lt;&lt;: 左移
+ ~: 按位非

+ ==: 等于
+ ~=: 不等于
+ &lt;: 小于
+ &gt;: 大于
+ &lt;=: 小于等于
+ &gt;=: 大于等于

+ and: 与
+ or: 或
+ not: 非


**强制转换**

位操作总是将浮点操作数转换成整数，乘方和浮点除法总是将整数转换为浮点数，其它数学操作符若针对混合操作数将整数转换为浮点数，这一点被称为通常规则。

从字符串到数字的转换过程遵循以下流程：首先，遵循按Lua词法分析器的规则分析语法来转换为对应的整数或浮点数，然后结果数字再次按前述规则转换为所需要的类型。

从数字转换为字符串使用非指定的人可读的格式。若想完全控制数字到字符串的转换过程，可以使用字符串库中的format函数。




## 编程接口

------

所有的API函数按相关的类型以及常量都声明在头文件lua.h中。C库中所有的Lua API函数都不去检查参数是否相容及有效，可以在编译Lua时加上打开一个宏开关`LUA)USE_APICHECK`来改变这个行为。


**栈**
Lua使用一个虚拟栈来和C互传值，栈上的每个元素都是一个Lua值(nil,数字，字符串等)

无论何时Lua调用C，被调用的函数都得到一个新的栈，这个栈独立于C函数本身的栈，也独立与之前的Lua栈。它里面包含了Lua传递给C函数的所有参数，而C函数则把要返回的结果放入这个栈以返回给调用者。

所有针对栈的API查询操作都不严格遵循栈的操作规则，而是可以用一个索引来指向栈上的任何元素，正的索引值的是栈上的绝对位置(从1开始)，负的索引指从栈顶开始的偏移量。


**栈大小**

使用lua_checkstack函数来扩大可用堆栈的尺寸。
无论何时Lua调用C，它都只保证至少有`LUA_MINSTACK`这么多的堆栈空间可以使用。一般被定义为20.


**有效索引与可接受索引**

API中的函数若要传入栈索引，这个索引必须是有效索引或者可接受索引。

有效索引指引用栈内真实位置的索引。任何可以接收有效索引的函数同时也接受伪索引，伪索引指代一些可以被C code访问得到Lua值，而他们又不在栈内。

对于那些以可接受索引调用的函数，无效索引被看做包含了一个虚拟类型LUA_TNONE的值，这个值的行为和nil一致。


**C 闭包**

Lua提供了一个注册表，这是一个预定义出来的表，可以用来保存任何C代码想保存的Lua值。这个表可用有效伪索引LUA_REGISTRYINDEX来定位。

当创建了一个新的Lua状态机，其中的注册表内就预订好了几个值，这些预定义值可以用整数索引到。这些整数以常数形式定义在lua.h中
+ LUA_RIDX_MAINTHREAD: 注册表中这个索引下是状态机的主线程(主线程和状态机同时被创建出来)

+ LUA_RIDX_GLOBALS: 注册表的这个索引下是全局环境


**C中的错误处理**

在内部实现中，Lua使用了C的longjmp机制来处理错误。如果发生保护环境之外，Lua会先调用panic函数，然后钓鱼用abort来退出宿主程序。panic函数只要不反悔，就可以不退出程序。


**C中的让出处理**

Lua内部使用C的longjmp机制让出一个协程。因此，如果一个C函数foo调用了API函数，而这个API函数让出了，由于longjmp会移除C栈的栈帧，Lua就无法返回到foo里了。

为了回避这类问题，碰到API调用中调用让出时，除了那些抛出错误的API外，还提供了三个函数:lua_yieldk,lua_callk,lua_pcallk。它们在让出发生时，可以从传入的延续函数继续运行。

Lua会把延续函数看作原函数。延续函数将接收到和原函数相同的Lua栈，其接收到的Lua状态也和被调函数若返回后应该有的状态一致。


**函数和类型**

[-o,+p,x]
第一个域指该函数会从栈上弹出多少个元素
第二个域指该函数会将多少个元素压栈。x|y这种形式的域表示该函数根据具体情况可能压入(或弹出)x或y个元素;问号表示无法仅通过参数来了解该函数会弹出/压入多少元素。
第三个域指该函数是否会抛出错误: '-'表示该函数不会抛出错误;'e'表示可能会抛出错误;'v'表示可能抛出有意义的错误




## Lua的完整语法

------

```
chuck ::= block
block ::= {stat}[restart]

stat ::= '**;**' | 
	varlist '**=**' explist |
	functioncall |
	label |
	**break** |
	**goto** Name |
	**do** block **end** |
	**while** exp **do** block **end** |
	**repeaat** block **until** exp |
	**if** exp **then** block {**elseif** exp **then** block} [**else** block] **end** |
	**for** Name '**=**' exp '**;**' exp ['**,**' exp] **do** block **end** |
	**for** namelist **in** explist **do** block **end** |
	**function** funcname funcbody | 
	**local** **function** Name funcbody |
	**local** namelist ['**=**' explist]

restart ::= **return** [explist]\['**;**'\]

label ::= '**::**' Name '**::**'

funcname ::= Name {'**.**' Name} ['**:**' Name]

varlist ::= var {'**,**' var}

var ::= Name | prefixexp '**[**' exp '**]**' | prefixexp '**.**' Name

namelist ::= Name {'**,**' Name}

explist ::= exp {'**,**' exp}

exp ::= **nil** | **false** | **true** | Numeral | LiteralString | '**...**' | functiondef | prefixexp | tableconstructor | exp binop exp | unop exp

prefixexp ::= var | functioncall | '**(**' exp '**)**'

functioncall ::= prefixexp args | prefixexp '**.**' Name args

args ::= '**(**' [explist] '**)**' | tableconstructor | LiteralString 

functiondef ::= **function** funcbody

funcbody ::= '**(**' [parlist] '**)**' block **end**

parlist ::= namelist ['**,**' '**...**'] | '**...**' 

tableconstructor ::= '**{**' [fieldlist] '**}**'

fieldlist ::= field {fieldsep field} [fieldsep]

field ::= '**[**' exp '**]**' '**=**' exp | Name '**=**' exp | exp

fieldsep ::= '**,**' | '**;**'

binop ::= ‘**+**’ | ‘**-**’ | ‘*****’ | ‘**/**’ | ‘**//**’ | ‘**^**’ | ‘**%**’ | ‘**&**’ | ‘**~**’ | ‘**|**’ | ‘**>>**’ | ‘**<<**’ | ‘**..**’ | ‘**<**’ | ‘**<=**’ | ‘**>**’ | ‘**>=**’ | ‘**==**’ | ‘**~=**’ | **and** | **or**

unop ::= '**-**' | **not** | '**#**' | '**~**'

```

