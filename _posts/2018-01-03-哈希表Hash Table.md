# 哈希表Hash Table

------

## 概述
**哈希表支持一个最有效的检索方式: 散列**
从根本上来说，一个哈希表包含一个数组，通过特殊的索引值(键)来访问数组中的元素

**哈希表的主要思想是通过一个哈希函数，在所有可能的键与槽位之间建立一张映射表。哈希函数每次接受一个键将返回与键相对应的哈希编码或哈希值。键的数据类型可能多种多样，但哈希值的类型只能是整型。**

计算哈希值和在数组中进行索引都只消耗固定的时间，因此哈希表的最大亮点在于它是一种运行时间在常量级的检索方法。当哈希值能够保证不同的键生成的哈希值互不相同时，就说哈希表能直接寻址想要的结果。但只是理想状态，在实际运用过程中，能够直接寻址结果的情况非常少

通常与各种各样的键相比，哈希表的条目相应较少，因此，绝大数的哈希函数会将一些不同的键映射到相同的槽位上。当两个键映射到一个相同的槽位上，就产生了冲突。一个好的哈希函数能最大限度的减少冲突，但冲突不能完全消除，仍要想办法处理这些冲突。


## 描述
链式哈希表从根本上说是一组链表构成。每个链表都可以看做是一个"桶"，将所有的元素通过散列的方式放到具体的不同的桶中。插入元素时，首先将其键传入一个哈希函数(该过程称为哈希键)，函数通过散列的方式告知元素属于哪个桶，然后在相应的链表头插入元素。
因为每个"桶"都是一个链表，所以链式哈希表并不限制包含元素的个数。然而，如果表变得太大，它的性能将会降低。


## 解决冲突
当哈希表中两个键散列到一个相同的槽位时，这两个键之间将会产生冲突。链式哈希表解决冲突的方法: 当冲突发生时，就将元素放到已经准备好的"桶"中。但这样会带来一个问题，当过多的冲突发生在同一槽位时，此位置的"桶"将会变得越来越深，从而造成访问这个位置的元素所需要的时间越来越多。

在理想情况下，希望所有的"桶"以集合同样的速度增长，这样它们就可以尽可能的保持小的容量和相同的大小。即尽可能的均匀和随机的分配表中的元素，这种情况理论上称为**均匀散列**。而在实际中，只能尽可能近似达到这种状态。

如果要插入表中的元素个数远大于表中"桶"的数量，那么即使在一个均匀散列的过程中，表的性能也会迅速下降。这种情况下，表中的所有"桶"都变得越来越深，因此，要特别注意一个哈希表的负载因子，其定义为:
```
a = n / m
```
其中的n表示表中元素的个数，m表示桶的个数。在均匀散列的情况下，链式哈希表的负载因子告诉我们表中的"桶"能装下元素个数的最大值。


## 哈希函数的选择
一个好的哈希函数旨在均匀散列。
**定义一个哈希函数，它将键k映射到哈希表中的位置x。x称为k的哈希编码，正式的表述为: 
```
h(k) = x
```
一般来说，大多数的散列方法都假设k为整数，容易以数学方式修改，从而使h能够更均匀分布在表中。当k不是一个整数时，也可以很容易的将它强制转换为整型。

**如何强制转换一组键，很大程度取决于键本身的特点。**

### 取余法
将整型k映射到m槽位的散列方法是计算k除以m所得到的余数，称之为取余法
```
h(k) = k mod m
```
通常选择的m是一个素数，且不要太接近2的幂，同时还要考虑存储空间限制和负载因子。


### 乘法
将整型k乘以一个常数A(0<A<1),取结果的小数部分，然后再乘以m取结果的整数部分。通常情况下，A取0.618
```
h(k) = m(kA mod 1)
```
这个方法有个优点是,对于表中的槽位个数m的选择并不需要像取余法中那么慎重。
在链式哈希表中，如果该期待插入的元素个数n不超过4500，可以让m=2250.