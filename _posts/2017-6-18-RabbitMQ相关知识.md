# AMQP 0-9-1简介

------

**消息系统允许软件，应用相互连接和扩展，这些应用可以相互链接起来组成一个更大的应用，或者将用户设备和数据进行连接。消息系统通过将消息的发送和接收分离来实现应用程序的异步和解耦**


AMQP(Advanced Message Queue Protocol，高级消息队列协议)是一个网络协议。它支持符合要求的客户端应用和消息中间件代理(messaging middleware broker)之间进行通信。

消息代理和他们所扮演的角色
消息代理(message brokers)从发布者(publiishers)亦称生产者(producers)那儿接收消息，并根据既定的路由规则把接收到的消息发送给处理消息的消费者。
由于AMQP是一个网络协议，所以这个过程中的发布者，消费者，消息代理可以存在于不同的设备上。

AMQP 0-9-1模型简介
其工作流程如下：消息(message)被发布者(publisher)发送给交换机(exchange),交换机常常被比喻成邮局或者邮箱。然后交换机将收到的消息根据路由规则分发给绑定地队列(queue)。最后AMQP代理会将消息投递给订阅了此队列的消费者，或者消费者按需求自行获取。

![amqp-01.png](https://aaron-13.github.io/images/amqp-01.png)

发布者(publisher)发布消息时可以给消息指定各种消息属性(message meta-data)。有些属性有可能会被消息代理(brokers)使用，然而其他的属性则是完全不透明的，它们只能被接收消息的应用所使用。
从安全角度考虑，网络是不可靠的，接收消息的应用也有可能在处理消息的时候失败。基于此原因，AMQP模块包含了一个消息确认(message acknowledgements)的概念：当一个消息从队列中投递给消费者后(consumer),消费者会通知一下消息代理(broker),这个可以是自动的也可以是由处理消息的开发者执行。当"消息确认"被启用的时候，消息代理不会完全将消息从队列中删除，直到它收到来自消费者的确认回执(acknowledgement)。

在某些情况下，例如当一个消息无法被成功路由时，消息或许会被返回给发布者并被丢弃。或者，如果消息代理执行了延期操作，消息会被放入一个所谓的死信队列中，此时，消息发布者可以选择某些参数来处理这些特殊情况。

队列，交换机和绑定统称为AMQP实体(AMQP entities)

**AMQP是一个可编程的协议**

AMQP 0-9-1是一个可编程协议，某种意义上说AMQP的实体和路由规则是由应用本身定义的，而不是消息代理定义的。包括像声明队列和交换机，定义它们之间的绑定，订阅队列等等关于协议本身的操作。


**交换机和交换机类型**
交换机是用来发送消息AMQP实体。交换机拿到一个消息之后将它路由给一个或零个队列。它使用哪种路由算法是由交换机类型和被称作绑定(bandings)的规则所决定的。AMQP 0-9-1的代理提供了四种交换机。

![amqp-02.png](https://aaron-13.github.io/images/amqp-02.png)

除了交换机类型外，在声明交换机时还可以附带许多其他的属性，其中最重要的几个分别是：

+ Name
+ Durability (消息代理重启后，交换机是否还存在)
+ Auto-delete (当所有与之绑定的消息队列都完成了对此交换机的使用后，删除)
+ Arguments (依赖代理本身)

交换机可以有两个状态: 持久(durable)，暂存(transient)。持久化的交换机会在消息代理(broker)重启后依旧存在，而暂存的交换机则不会。


**默认交换机**

默认交换机(default exchange)实际上是一个由消息代理预先声明好的没有名字(名字为空字符串)的直连交换机(direct exchange).它有一个特殊的属性使得它对于简单应用特别有用: 那就是每个新建队列(queue)都会自动绑定到默认交换机上，绑定地路由键(routing key)名称和队列名称相同。


**直连交换机**
直连型交换机(direct exchange)是根据消息携带的路由键(routing key)将消息投递给对应队列的。直连交换机用来处理消息的单播路由(unicast routing)，其工作流程：

+ 将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键(routing key)

+ 当一个携带这路由键为R的消息被发送给直连交换机，交换机会把它路由给绑定值同样为R的队列

直连交换机经常用来循环分发任务给多个工作者(workers)。在AMQP 0-9-1中，消息的负载均衡是发生在消费者(consumer)之间的，而不是队列之间。

![amqp-05.png](https://aaron-13.github.io/images/amqp-05.png)


**扇形交换机**

扇形交换机(funout exchange)将消息路由给绑定到它身上的所有队列，而不理会绑定地路由键。如果N个队列绑定到某个扇形交换机上，当有消息发送给此扇形交换机时，交换机会将消息的拷贝分别发送给所有的N个队列。扇形交换机用来处理消息的广播路由(broadcast routing)。

因为扇形交换机投递消息的拷贝到所有绑定到它的队列，所以其应用案例都相似：

+ 大规模多用户在线(MMO)游戏可以使用它来处理排行榜更新等全局事件

+ 体育新闻网站可以用它来近乎实时将比分更新发给移动客户端

+ 分发系统使用它来广播各种状态和配置更新

+ 在群聊的时候，被用来分发消息给参与群聊的用户。(AMQP没有内置persence的概念，因此XMPP可能会是更好地选择)

![amqp-06.png](https://aaron-13.github.io/images/amqp-06.png)


**主题交换机(topic exchange)**

主题交换机(topic exchange)通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由(broadcast routing)。
主题交换机拥有非常广泛的用户案例。当一个问题涉及到那些想要有针对性的选择需要接受消息的多消费者/多应用(multiple consumers/applications)的时候，主题交换机都可以被列入考虑范围。

使用案例：

+ 分发有关于特定地理位置的数据，如销售点

+ 由多个工作者(worker)完成的后台任务，每个工作者负责处理某些特定的任务

+ 股票价格更新(以及其他类型的金融数据更新)

+ 涉及到分类或者标签的新闻更新(例如:针对特定的运动项目或者队伍)

+ 云端的不同种类服务的协调

+ 分布式架构/基于系统的软件封装，其中每个构建者仅能处理一个特定的架构或者系统


**头交换机**

有时消息的路由操作会涉及到多个属性，此时使用消息头就比用路由键更容易表达，头交换机(headers exchange)就是为此而生的。头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。
绑定一个队列到头交换机上，并给他们之间绑定使用多个用于匹配的头(header)。这个案例中，消息代理得从应用开发者那么获取更多一段信息，即它需要考虑某条消息(message)是需要部分匹配还是全部匹配。上边说的"更多一段消息"就是"X-match"参数，当该参数设置为"any"时，消息头的任意一个值被匹配就可以满足条件，而当该参数设置为"all"的时候，就需要消息头的所有值都匹配成功。

头交换机可以视为直连交换机的另一种表现形式。头交换机能够像直连交换机一样工作。不同之处在于头交换机的路由规则是建立在头属性之上，而不是路由键。路由键必须是一个字符串，而头属性值则没有这个约束，它们设置可以是整数或者哈希值(字典)等。


**队列**

AMQP中的队列(queue)跟其他消息队列或任务队列中的队列很相似：它们存储着即将被应用消费掉的消息。队列跟交换机共享某些属性，但是队列也有一些另外的属性。

+ Name

+ Durable (消息代理重启后，队列依旧存在)

+ Exclusive (只被一个连接(connection)使用，而且当连接关闭后队列即被删除)

+ Auto-delete (当最后一个消费者退订后即被删除)

+ Arguments (一些消息代理用它来完成类似于与TTL的某些额外功能)


队列在声明(declare)后才能被使用。如果队列不存在，声明时就会创建。如果声明的队列已经存在，并属性完全相同，那么此次声明不会对原有队列产生任何影响。如果生命中的属性与已经存在队列有差异，那么一个错误代码为406的通道级异常就会被抛出。


**队列名称**

队列的名称可以由应用(application)来取，也可以让消息代理(broker)直接生成一个。队列的名字可以是最多255字节的一个utf-8字符串。若希望AMQP消息代理生产队列名，需要给队列的name参数赋值一个空字符串：在同一通道(channel)的后续方法method中，可以使用空字符串来表示之前生成的队列名称。之所以之后的方法可以获取正确的队列名是因为通道可以默默地记住消息代理最后一次生成的队列名称。

以"amq."开始的队列名称被预留做消息代理内部使用。如果试图在队列声明时打破这一规则的话，一个通道级的403(ACCESS_REFUSED)错误会被抛出。


**队列持久化**

持久化队列(Durable queues)会被存储在磁盘上，但消息代理(broker)重启的时候，依旧存在。没有被持久化的队列被称为暂存队列(Transient queues)，并不是所有场景都需要持久化队列。

持久化队列并不会使得路由到它的消息也具有持久性。如果消息代理挂了，重启启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。



**绑定**

绑定(banding)是交换机(exchange)将消息(message)路由给队列(queue)所遵循的规则。如果要指示交换机E将消息路由给队列Q，那么 Q就需要与E进行绑定。绑定操作需要定义一个可选的路由键(routing key)属性给某些类型的交换机。路由键的意义在于从发送给交换机的众多消息中选择出某些消息，将其路由给绑定的队列。

如果AMQP的消息无法路由到队列，消息就会被销毁或者返回给发布者，如何处理取决于发布者设置的消息属性。


**消费者**

消息如果只是存储在队列中没有任何用处。被应用消费掉，消息的价值才能够体现。在AMQP 0-9-1模型中，有两种途径可以达到此目的。

+ 将消息投递给应用("push API")

+ 应用根据需要主动获取消息("pull API")

使用push API，应用需要明确表示出它在某个特定队列里所感兴趣的，想要消费的消息。如是，可以说应用注册了一个消费者，或者说订阅了一个队列。一个队列可以注册多个消费者，也可以注册一个独享的消费者。
每个消费者都有一个叫做消费者标签的标识符，可以被用来退订。消费者标签实际上是一个字符串。


**消息确认**

消费者应用(Consumer applications)用来接收和处理消息的应用，在处理消息的时候偶尔会失败或者直接崩溃掉。而且网络原因也可能会引起各种问题。AMQP代理在什么时候删除消息才是正确的? AMQP 0-9-1规范给了两种建议：

+ 当消息代理(broker)将消息发送给应用后立即删除。 (使用AMQP方法：basic.deliver或basic.get-ok)

+ 待应用(application)发送一个确认回执(acknowledgement)后再删除消息。(使用AMQP方法：basic.ack)

前者被称作自动确认模式(automatic acknowledgement mode),后者被称作显示确认模式(explici acknowledgement model)。在显示模式下，由消费者应用来选择什么时候发送确认回执(acknowledgement)。应用可以在收到消息后立即发送，或将未处理的消息存储后发送，或等到消息被处理完毕后再发送确认回执

如果一个消费者在尚未发送确认回执的情况下挂掉了，那AMQP代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。



**拒绝消息**

当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于"拒绝消息(rejecting messages)"的原因处理失败了--销毁它或者重新放入队列。当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择重放入队列而引起消息在同一个消费者身上无限循环的情况发生。


**预取消息**

在多个消息者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接收多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。

注意：RabbitMQ只支持通道级的预取计数，而不是连接级的或者基于大小的预取


**消息属性和有效荷载(消息主体)**

AMQP模型中的消息(message)对象是带有属性(attributes)的。有些属性及其常见，以至于AMQP 0-9-1明确定义了它们：

+ Content type (内容类型)

+ Content encoding (内容编码)

+ Routing key (路由键)

+ Delivery mode (persistent or not) 投递模式(持久化或非持久化)

+ Message priority (消息优先权)

+ Message publishing timestamp (消息发布的时间戳)

+ Expiration period (消息有效期)

+ Publisher application id (发布应用的ID)

有些属性是被AMQP代理所使用的，但是大多数是开始给接收它们的应用解释器用的。有些属性是可选的也被称作消息头(Headers)。他们跟HTTP协议的X-Headers很相似。消息属性需要在消息被发布的时候定义。

AMQP的消息除属性外，也含有一个有效荷载Payload(消息实际携带的数据)，它被AMQP代理当做不透明的字节数组来对待。消息代理不会检查或者修改有效荷载。消息可以只包含属性而不被携带有效荷载。他通常会使用类似JSON这种序列化的格式数据，为了节省，协议缓冲器和MessagePack将结构化数据序列化，以便以消息的有效荷载的形式发布。AMQP及其同行者通常使用"content-type"和"content-encoding"这两个字段来与消息沟通进行有效荷载的辨识工作，但这仅仅是基于约定而已。
消息能够以持久化的方式发布，AMQP代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。简单地将消息发送给一个持久化的交换机或者路由给一个持久化队列，并不会使得此消息具有持久化性质，他完全取决与消息本身的持久模式(persistence mode)。将消息以持久化方式发布时，会对性能造成一定的影响(就像数据库操作一样，健壮性的存在必定造成一些性能的牺牲)


**消息确认**

由于网络的不确定性和应用失败的可能性，处理确认回执(acknowledgement)就变得十分重要。有时，我们确认消费者收到消息就可以了，有时确认回执意味着消息已被验证并且处理完毕，例如对某些数据已经验证完毕并且进行了数据存储或者索引操作。

这种情形很常见，所以AMQP 0-9-1内置了一个功能叫做消息确认(message acknowledgements)，消费者用它来确认消息已经被接收或者处理。如果一个应用崩溃掉，而且消息的确认回执功能已经被开启，但是消息代理尚未获得确认回执，那么消息会被重新放入队列(并且在还有其他消费者存在于此队列的前提下，立即投递给另一个消费者)。


**AMQP 0-9-1方法**

AMQP 0-9-1由许多方法构成。AMQP的方法被分组在类(class)中，这里的类仅仅是对AMQP方法的逻辑分组而已。

交换机类，有一组方法被关联到交换机的操作上。这些方法如下所示：
+ exchange.declare

+ exchange.declare-ok

+ exchange.delete

+ exchange.delete-ok

这些操作分为"请求-requests"(由客户端发送)和"响应-responses"(由代理发送，用来回应之前提到的"请求"操作)

如下的例子：客户端要求消息代理使用exchange.declare方法声明一个新的交换机

![amqp-07.png](https://aaron-13.github.io/images/amqp-07.png)

exchange.declare方法携带了好几个参数，这些参数可以允许客户端指定交换机名称，类型，是否持久化等


操作成功后，消息代理使用exchange.declare-ok方法进行回应
![amqp-08.png](https://aaron-13.github.io/images/amqp-08.png)

exchange.declare-ok方法除了通道信号之外没有携带任何其他参数。

AMQP队列类的陪对方法--queue.declare方法和queue.declare-ok有着与其他陪对方法非常相似的一系列事件：
![amqp-09.png](https://aaron-13.github.io/images/amqp-09.png)

不是所有的AMQP方法都有与其配对的另一半，许多(basic.publish是被广泛使用的)都没有相对应的响应方法，另一些(basic.get)有着一种以上对应的响应方法。


**连接**

AMQP连接通常是长连接，AMQP是一个使用TCP提供可靠投递的应用层协议，AMQP使用认证机制并且提供TLS(SSL)保护。当一个应用不需要连接到AMQP代理的时候，需要优雅的释放掉AMQP连接，而不是直接将TCP连接关闭。


**通道**

有些应用需要与AMQP代理建立多个连接，无论怎样，同时开启多个TCP连接都是不合适的，因为这样做会消耗掉过多的系统资源并且使得防火墙的配置更加困难。AMQP 0-9-1提供了通道(channels)来处理多连接，可以把通道理解成共享一个TCP连接的多个轻量化连接。

在涉及多线程/进程的应用中，为每个线程/进程开启一个通道(channel)是很常见的，并且这些通道不能被线程/进程共享。

一个特定通道上的通讯与其他通道上的通讯是完全隔离的，因此，每个AMQP方法都需要携带一个通道号，这样客户端就可以指定此方法是为哪个通道准备的。


**虚拟主机**

为了在一个单独的代理上实现多个隔离的环境，AMQP提供了一个虚拟主机(virtual hosts -vhosts)的概念。这跟web servers虚拟主机概念相似，这为AMQP实体提供了完全隔离的环境，当连接被建立的时候，AMQP客户端来指定使用哪个虚拟主机。


**AMQP是可扩展的**

AMQP 0-9-1拥有多个扩展点：

+ 定制化交换机类型可以让开发者实现一些开箱即用的交换机类型尚未覆盖的路由方案

+ 交换机和队列声明中国可以包含一些消息代理能够用到的额外属性。例如RabbitMQ的per-queue message TTL即是使用该方案的实现

+ 特定消息代理的协议扩展

+ 新的AMQP 0-9-1方法类可被引入

+ 消息代理可以被其他的插件扩展，例如RabbitMQ的管理前段和已经被插件化的HTTP API



**AMQP 0-9-1客户端生态系统**

AMQP 0-9-1拥有众多的适用于各种流行语言和框架的客户端，其中一部分严格遵循AMQP规范，提供AMQP方法的实现，另一部分提供了额外的技术，方便使用的方法和抽象。有些客户端是异步的(非阻塞)，有些事同步的(阻塞)，有些将这两者同时实现。有些客户端支持"供应商的特定扩展"。

因为AMQP的主要目标之一就是实现交互性，所以对开发者，了解协议的操作方法而不是只停留在弄懂特定客户端的库就显得十分重要。